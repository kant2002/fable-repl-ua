import{toString as dateToString}from"./Date.js";import{compare as numericCompare,isNumeric,multiply,toExponential,toFixed,toHex,toPrecision}from"./Numeric.js";import{escape}from"./RegExp.js";import{toString}from"./Types.js";const fsFormatRegExp=/(^|[^%])%([0+\- ]*)(\*|\d+)?(?:\.(\d+))?(\w)/g,interpolateRegExp=/(?:(^|[^%])%([0+\- ]*)(\d+)?(?:\.(\d+))?(\w))?%P\(\)/g,formatRegExp=/\{(\d+)(,-?\d+)?(?:\:([a-zA-Z])(\d{0,2})|\:(.+?))?\}/g;function isLessThan(t,e){return numericCompare(t,e)<0}function cmp(t,e,n){function r(t){return!0===t||1===t||3===t||5===t}return null==t?null==e?0:-1:null==e?1:4===(o=n)||5===o?(r(n)&&(t=t.toLowerCase(),e=e.toLowerCase()),t===e?0:t<e?-1:1):(r(n)&&(t=t.toLocaleLowerCase(),e=e.toLocaleLowerCase()),t.localeCompare(e));var o}export function compare(...t){switch(t.length){case 2:return cmp(t[0],t[1],!1);case 3:return cmp(t[0],t[1],t[2]);case 4:return cmp(t[0],t[1],!0===t[2]);case 5:return cmp(t[0].substr(t[1],t[4]),t[2].substr(t[3],t[4]),!1);case 6:return cmp(t[0].substr(t[1],t[4]),t[2].substr(t[3],t[4]),t[5]);case 7:return cmp(t[0].substr(t[1],t[4]),t[2].substr(t[3],t[4]),!0===t[5]);default:throw new Error("String.compare: Unsupported number of parameters")}}export function compareOrdinal(t,e){return cmp(t,e,4)}export function compareTo(t,e){return cmp(t,e,0)}export function startsWith(t,e,n){return t.length>=e.length&&0===cmp(t.substr(0,e.length),e,n)}export function indexOfAny(t,e,...n){if(null==t||""===t)return-1;const r=n.length>0?n[0]:0;if(r<0)throw new Error("Start index cannot be negative");const o=n.length>1?n[1]:t.length-r;if(o<0)throw new Error("Length cannot be negative");if(o>t.length-r)throw new Error("Invalid startIndex and length");t=t.substr(r,o);for(const n of e){const e=t.indexOf(n);if(e>-1)return e+r}return-1}export function printf(t){return{input:t,cont:fsFormat(t)}}export function interpolate(t,e){let n=0,r=0,o="";interpolateRegExp.lastIndex=0;let i=interpolateRegExp.exec(t);for(;i;){const s=i.index+(i[1]||"").length;o+=t.substring(r,s).replace(/%%/g,"%");const[,,a,u,l,c]=i;r=interpolateRegExp.lastIndex,o+=formatReplacement(e[n++],a,u,l,c),interpolateRegExp.lastIndex=r-1,i=interpolateRegExp.exec(t)}return o+=t.substring(r).replace(/%%/g,"%"),o}function continuePrint(t,e){return"string"==typeof e?t(e):e.cont(t)}export function toConsole(t){return continuePrint((t=>console.log(t)),t)}export function toConsoleError(t){return continuePrint((t=>console.error(t)),t)}export function toText(t){return continuePrint((t=>t),t)}export function toFail(t){return continuePrint((t=>{throw new Error(t)}),t)}function formatReplacement(t,e,n,r,o){let i="";if(e=e||"",o=o||"",isNumeric(t))switch("x"!==o.toLowerCase()&&(isLessThan(t,0)?(t=multiply(t,-1),i="-"):e.indexOf(" ")>=0?i=" ":e.indexOf("+")>=0&&(i="+")),r=null==r?null:parseInt(r,10),o){case"f":case"F":t=toFixed(t,r=null!=r?r:6);break;case"g":case"G":t=null!=r?toPrecision(t,r):toPrecision(t);break;case"e":case"E":t=null!=r?toExponential(t,r):toExponential(t);break;case"x":t=toHex(t);break;case"X":t=toHex(t).toUpperCase();break;default:t=String(t)}else t=t instanceof Date?dateToString(t):toString(t);if(n="number"==typeof n?n:parseInt(n,10),isNaN(n))t=i+t;else{const r=e.indexOf("0")>=0,o=e.indexOf("-")>=0,s=o||!r?" ":"0";t="0"===s?i+(t=pad(t,n-i.length,s,o)):pad(i+t,n,s,o)}return t}function createPrinter(t,e,n,r="",o=-1){return(...i)=>{let s=r;const a=e.slice(),u=n.slice();for(const t of i){const[,,e,n,r,i]=u[0];let l=n;if(o>=0)l=o,o=-1;else if("*"===l){if(t<0)throw new Error("Non-negative number required");o=t;continue}s+=a[0],s+=formatReplacement(t,e,l,r,i),a.splice(0,1),u.splice(0,1)}return 0===u.length?(s+=a[0],t(s)):createPrinter(t,a,u,s,o)}}export function fsFormat(t){return e=>{fsFormatRegExp.lastIndex=0;const n=[],r=[];let o=0,i=fsFormatRegExp.exec(t);for(;i;){const e=i.index+(i[1]||"").length;n.push(t.substring(o,e).replace(/%%/g,"%")),r.push(i),o=fsFormatRegExp.lastIndex,fsFormatRegExp.lastIndex-=1,i=fsFormatRegExp.exec(t)}return 0===n.length?e(t.replace(/%%/g,"%")):(n.push(t.substring(o).replace(/%%/g,"%")),createPrinter(e,n,r))}}export function format(t,...e){let n;return"object"==typeof t?(n=String(e[0]),e.shift()):n=t,n.replace(formatRegExp,((t,n,r,o,i,s)=>{if(n<0||n>=e.length)throw new Error("Index must be greater or equal to zero and less than the arguments' length.");let a=e[n];if(isNumeric(a))switch(i=null==i?null:parseInt(i,10),o){case"f":case"F":a=toFixed(a,i=null!=i?i:2);break;case"g":case"G":a=null!=i?toPrecision(a,i):toPrecision(a);break;case"e":case"E":a=null!=i?toExponential(a,i):toExponential(a);break;case"p":case"P":i=null!=i?i:2,a=toFixed(multiply(a,100),i)+" %";break;case"d":case"D":a=null!=i?padLeft(String(a),i,"0"):String(a);break;case"x":case"X":a=null!=i?padLeft(toHex(a),i,"0"):toHex(a),"X"===o&&(a=a.toUpperCase());break;default:if(s){let t="";a=s.replace(/([0#,]+)(\.[0#]+)?/,((e,n,r)=>{isLessThan(a,0)&&(a=multiply(a,-1),t="-"),r=null==r?"":r.substring(1),a=toFixed(a,Math.max(r.length,0));let[o,i]=a.split(".");i||(i=""),o=padLeft(o,n.replace(/,/g,"").replace(/^#+/,"").length,"0");const s=r.replace(/#+$/,"").length;if(s>i.length?i=padRight(i,s,"0"):s<i.length&&(i=i.substring(0,s)+i.substring(s).replace(/0+$/,"")),n.indexOf(",")>0){const t=o.length%3,e=Math.floor(o.length/3);let n=t>0?o.substr(0,t)+(e>0?",":""):"";for(let r=0;r<e;r++)n+=o.substr(t+3*r,3)+(r<e-1?",":"");o=n}return i.length>0?o+"."+i:o})),a=t+a}}else a=a instanceof Date?dateToString(a,s||o):toString(a);return r=parseInt((r||" ").substring(1),10),isNaN(r)||(a=pad(String(a),Math.abs(r)," ",r<0)),a}))}export function endsWith(t,e){const n=t.lastIndexOf(e);return n>=0&&n===t.length-e.length}export function initialize(t,e){if(t<0)throw new Error("String length must be non-negative");const n=new Array(t);for(let r=0;r<t;r++)n[r]=e(r);return n.join("")}export function insert(t,e,n){if(e<0||e>t.length)throw new Error("startIndex is negative or greater than the length of this instance.");return t.substring(0,e)+n+t.substring(e)}export function isNullOrEmpty(t){return"string"!=typeof t||0===t.length}export function isNullOrWhiteSpace(t){return"string"!=typeof t||/^\s*$/.test(t)}export function concat(...t){return t.map((t=>String(t))).join("")}export function join(t,e){return Array.isArray(e)?e.join(t):Array.from(e).join(t)}export function joinWithIndices(t,e,n,r){const o=n+r;if(o>e.length)throw new Error("Index and count must refer to a location within the buffer.");return e.slice(n,o).join(t)}function notSupported(t){throw new Error("The environment doesn't support '"+t+"', please use a polyfill.")}export function toBase64String(t){let e="";for(let n=0;n<t.length;n++)e+=String.fromCharCode(t[n]);return"function"==typeof btoa?btoa(e):notSupported("btoa")}export function fromBase64String(t){const e="function"==typeof atob?atob(t):notSupported("atob"),n=new Uint8Array(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);return n}function pad(t,e,n,r){n=n||" ",e-=t.length;for(let o=0;o<e;o++)t=r?t+n:n+t;return t}export function padLeft(t,e,n){return pad(t,e,n)}export function padRight(t,e,n){return pad(t,e,n,!0)}export function remove(t,e,n){if(e>=t.length)throw new Error("startIndex must be less than length of string");if("number"==typeof n&&e+n>t.length)throw new Error("Index and count must refer to a location within the string.");return t.slice(0,e)+("number"==typeof n?t.substr(e+n):"")}export function replace(t,e,n){return t.replace(new RegExp(escape(e),"g"),n)}export function replicate(t,e){return initialize(t,(()=>e))}export function getCharAtIndex(t,e){if(e<0||e>=t.length)throw new Error("Index was outside the bounds of the array.");return t[e]}export function split(t,e,n,r){if(r="number"==typeof r?r:0,(n="number"==typeof n?n:void 0)&&n<0)throw new Error("Count cannot be less than zero");if(0===n)return[];const o=1==(1&r),i=2==(2&r);e=(e=(e=e||[]).filter((t=>t)).map(escape)).length>0?e:["\\s"];const s=[],a=new RegExp(e.join("|"),"g");let u=!0,l=0;do{const e=a.exec(t);if(null===e){const e=i?t.substring(l).trim():t.substring(l);(!o||e.length>0)&&s.push(e),u=!1}else{const r=i?t.substring(l,e.index).trim():t.substring(l,e.index);(!o||r.length>0)&&(null!=n&&s.length+1===n?(s.push(i?t.substring(l).trim():t.substring(l)),u=!1):s.push(r)),l=a.lastIndex}}while(u);return s}export function trim(t,...e){if(0===e.length)return t.trim();const n="["+escape(e.join(""))+"]+";return t.replace(new RegExp("^"+n),"").replace(new RegExp(n+"$"),"")}export function trimStart(t,...e){return 0===e.length?t.trimStart():t.replace(new RegExp("^["+escape(e.join(""))+"]+"),"")}export function trimEnd(t,...e){return 0===e.length?t.trimEnd():t.replace(new RegExp("["+escape(e.join(""))+"]+$"),"")}export function filter(t,e){return e.split("").filter((e=>t(e))).join("")}export function substring(t,e,n){if(e+(n||0)>t.length)throw new Error("Invalid startIndex and/or length");return null!=n?t.substr(e,n):t.substr(e)}export function fmt(t,...e){return{strs:t,args:e}}export function fmtWith(t){return(e,...n)=>({strs:e,args:n,fmts:t})}export function getFormat(t){return t.fmts?t.strs.reduce(((e,n,r)=>e+`{${String(r-1)+t.fmts[r-1]}}`+n)):t.strs.reduce(((t,e,n)=>t+`{${n-1}}`+e))}