import{OperationCanceledError,Trampoline}from"./AsyncBuilder.js";import{CancellationToken}from"./AsyncBuilder.js";import{protectedCont}from"./AsyncBuilder.js";import{protectedBind}from"./AsyncBuilder.js";import{protectedReturn}from"./AsyncBuilder.js";import{Choice_makeChoice1Of2,Choice_makeChoice2Of2}from"./Choice.js";import{TimeoutException}from"./SystemException.js";export class Async{}function emptyContinuation(e){}function delay(e){return protectedCont((n=>e()(n)))}export function makeAsync(e){return e}export function invoke(e,n){return e(n)}export function callThenInvoke(e,n,t){return t(n)(e)}export function bind(e,n,t){return protectedBind(n,t)(e)}export function createCancellationToken(e){const n=new CancellationToken("boolean"==typeof e&&e);return"number"==typeof e&&setTimeout((()=>{n.cancel()}),e),n}export function cancel(e){e.cancel()}export function cancelAfter(e,n){setTimeout((()=>{e.cancel()}),n)}export function isCancellationRequested(e){return null!=e&&e.isCancelled}export function throwIfCancellationRequested(e){if(null!=e&&e.isCancelled)throw new Error("Operation is cancelled")}function throwAfter(e){return protectedCont((n=>{let t;const o=setTimeout((()=>{n.cancelToken.removeListener(t),n.onError(new TimeoutException)}),e);t=n.cancelToken.addListener((()=>{clearTimeout(o),n.onCancel(new OperationCanceledError)}))}))}export function startChild(e,n){if(n)return startChild(protectedBind(parallel2(e,throwAfter(n)),(e=>protectedReturn(e[0]))));const t=startAsPromise(e);return protectedCont((e=>protectedReturn(awaitPromise(t))(e)))}export function awaitPromise(e){return fromContinuations((n=>e.then(n[0]).catch((e=>(e instanceof OperationCanceledError?n[2]:n[1])(e)))))}export function cancellationToken(){return protectedCont((e=>e.onSuccess(e.cancelToken)))}export const defaultCancellationToken=new CancellationToken;export function catchAsync(e){return protectedCont((n=>{e({onSuccess:e=>n.onSuccess(Choice_makeChoice1Of2(e)),onError:e=>n.onSuccess(Choice_makeChoice2Of2(e)),onCancel:n.onCancel,cancelToken:n.cancelToken,trampoline:n.trampoline})}))}export function fromContinuations(e){return protectedCont((n=>e([n.onSuccess,n.onError,n.onCancel])))}export function ignore(e){return protectedBind(e,(e=>protectedReturn(void 0)))}export function parallel(e){return delay((()=>awaitPromise(Promise.all(Array.from(e,(e=>startAsPromise(e)))))))}function parallel2(e,n){return delay((()=>awaitPromise(Promise.all([startAsPromise(e),startAsPromise(n)]))))}export function sequential(e){return delay((()=>awaitPromise(function(e){let n=Promise.resolve([]);for(const t of e)n=n.then((e=>startAsPromise(t).then((n=>e.concat([n])))));return n}(e))))}export function sleep(e){return protectedCont((n=>{let t;const o=setTimeout((()=>{n.cancelToken.removeListener(t),n.onSuccess(void 0)}),e);t=n.cancelToken.addListener((()=>{clearTimeout(o),n.onCancel(new OperationCanceledError)}))}))}export function runSynchronously(){throw new Error("Asynchronous code cannot be run synchronously in JS")}export function start(e,n){return startWithContinuations(e,n)}export function startImmediate(e,n){return start(e,n)}export function startWithContinuations(e,n,t,o,r){"function"!=typeof n&&(r=n,n=void 0);const c=new Trampoline;e({onSuccess:n||emptyContinuation,onError:t||emptyContinuation,onCancel:o||emptyContinuation,cancelToken:r||defaultCancellationToken,trampoline:c})}export function startAsPromise(e,n){return new Promise(((t,o)=>startWithContinuations(e,t,o,o,n||defaultCancellationToken)))}export default Async;