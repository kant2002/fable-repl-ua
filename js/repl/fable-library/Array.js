import{Helpers_allocateArrayFromCons}from"./Native.js";import{value as value_2,map as map_1,defaultArg,some}from"./Option.js";import{min as min_1,equals as equals_1,disposeSafe,getEnumerator,copyToArray,defaultOf,comparePrimitives,max as max_1}from"./Util.js";import{SR_indexOutOfBounds}from"./Global.js";function indexNotFound(){throw new Error("An index satisfying the predicate was not found in the collection.")}function differentLengths(){throw new Error("Arrays had different lengths")}export function append(e,t,r){const n=0|e.length,o=0|t.length,l=Helpers_allocateArrayFromCons(r,n+o);for(let t=0;t<=n-1;t++)l[t]=e[t];for(let e=0;e<=o-1;e++)l[e+n]=t[e];return l}export function filter(e,t){return t.filter(e)}export function fill(e,t,r,n){const o=0|t;return e.fill(n,o,o+r)}export function getSubArray(e,t,r){const n=0|t;return e.slice(n,n+r)}export function last(e){if(0===e.length)throw new Error("The input array was empty\\nParameter name: array");return e[e.length-1]}export function tryLast(e){return 0===e.length?void 0:some(e[e.length-1])}export function mapIndexed(e,t,r){const n=0|t.length,o=Helpers_allocateArrayFromCons(r,n);for(let r=0;r<=n-1;r++)o[r]=e(r,t[r]);return o}export function map(e,t,r){const n=0|t.length,o=Helpers_allocateArrayFromCons(r,n);for(let r=0;r<=n-1;r++)o[r]=e(t[r]);return o}export function mapIndexed2(e,t,r,n){if(t.length!==r.length)throw new Error("Arrays had different lengths");const o=Helpers_allocateArrayFromCons(n,t.length);for(let n=0;n<=t.length-1;n++)o[n]=e(n,t[n],r[n]);return o}export function map2(e,t,r,n){if(t.length!==r.length)throw new Error("Arrays had different lengths");const o=Helpers_allocateArrayFromCons(n,t.length);for(let n=0;n<=t.length-1;n++)o[n]=e(t[n],r[n]);return o}export function mapIndexed3(e,t,r,n,o){if(t.length!==r.length||r.length!==n.length)throw new Error("Arrays had different lengths");const l=Helpers_allocateArrayFromCons(o,t.length);for(let o=0;o<=t.length-1;o++)l[o]=e(o,t[o],r[o],n[o]);return l}export function map3(e,t,r,n,o){if(t.length!==r.length||r.length!==n.length)throw new Error("Arrays had different lengths");const l=Helpers_allocateArrayFromCons(o,t.length);for(let o=0;o<=t.length-1;o++)l[o]=e(t[o],r[o],n[o]);return l}export function mapFold(e,t,r,n){const o=0|r.length;if(0===o)return[[],t];{let l=t;const i=Helpers_allocateArrayFromCons(n,o);for(let t=0;t<=r.length-1;t++){const n=e(l,r[t]);i[t]=n[0],l=n[1]}return[i,l]}}export function mapFoldBack(e,t,r,n){const o=0|t.length;if(0===o)return[[],r];{let l=r;const i=Helpers_allocateArrayFromCons(n,o);for(let r=t.length-1;r>=0;r--){const n=e(t[r],l);i[r]=n[0],l=n[1]}return[i,l]}}export function indexed(e){const t=0|e.length,r=new Array(t);for(let n=0;n<=t-1;n++)r[n]=[n,e[n]];return r}export function truncate(e,t){const r=0|max_1(comparePrimitives,0,e);return t.slice(0,0+r)}export function concat(e,t){const r=Array.isArray(e)?e:Array.from(e),n=0|r.length;if(0===n)return Helpers_allocateArrayFromCons(t,0);if(1===n)return r[0];{let e=0,n=0;for(let e=0;e<=r.length-1;e++)n=n+r[e].length|0;const o=Helpers_allocateArrayFromCons(t,n);for(let t=0;t<=r.length-1;t++){const n=r[t];for(let t=0;t<=n.length-1;t++)o[e]=n[t],e=e+1|0}return o}}export function collect(e,t,r){return concat(map(e,t,defaultOf()),r)}export function where(e,t){return t.filter(e)}export function indexOf(e,t,r,n,o){const l=0|defaultArg(r,0);let i;const u=map_1((e=>l+e),n),a=0|e.length;return i=defaultArg(u,a),0|(r=>{for(;;){const n=r;if(n>=i)return-1;if(o.Equals(t,e[n]))return 0|n;r=n+1}})(l)}export function contains(e,t,r){return indexOf(t,e,void 0,void 0,r)>=0}export function empty(e){return Helpers_allocateArrayFromCons(e,0)}export function singleton(e,t){const r=Helpers_allocateArrayFromCons(t,1);return r[0]=e,r}export function initialize(e,t,r){if(e<0)throw new Error("The input must be non-negative\\nParameter name: count");const n=Helpers_allocateArrayFromCons(r,e);for(let r=0;r<=e-1;r++)n[r]=t(r);return n}export function pairwise(e){if(e.length<2)return[];{const t=e.length-1|0,r=new Array(t);for(let n=0;n<=t-1;n++)r[n]=[e[n],e[n+1]];return r}}export function replicate(e,t,r){if(e<0)throw new Error("The input must be non-negative\\nParameter name: count");const n=Helpers_allocateArrayFromCons(r,e);for(let e=0;e<=n.length-1;e++)n[e]=t;return n}export function copy(e){return e.slice()}export function copyTo(e,t,r,n,o){copyToArray(e,t,r,n,o)}export function reverse(e){return e.slice().reverse()}export function scan(e,t,r,n){const o=Helpers_allocateArrayFromCons(n,r.length+1);o[0]=t;for(let t=0;t<=r.length-1;t++)o[t+1]=e(o[t],r[t]);return o}export function scanBack(e,t,r,n){const o=Helpers_allocateArrayFromCons(n,t.length+1);o[t.length]=r;for(let r=t.length-1;r>=0;r--)o[r]=e(t[r],o[r+1]);return o}export function skip(e,t,r){if(e>t.length)throw new Error("count is greater than array length\\nParameter name: count");if(e===t.length)return Helpers_allocateArrayFromCons(r,0);{const r=0|(e<0?0:e);return t.slice(r)}}export function skipWhile(e,t,r){let n=0;for(;n<t.length&&e(t[n]);)n=n+1|0;if(n===t.length)return Helpers_allocateArrayFromCons(r,0);{const e=0|n;return t.slice(e)}}export function take(e,t,r){if(e<0)throw new Error("The input must be non-negative\\nParameter name: count");if(e>t.length)throw new Error("count is greater than array length\\nParameter name: count");if(0===e)return Helpers_allocateArrayFromCons(r,0);{const r=0;return t.slice(r,r+e)}}export function takeWhile(e,t,r){let n=0;for(;n<t.length&&e(t[n]);)n=n+1|0;if(0===n)return Helpers_allocateArrayFromCons(r,0);{const e=0,r=0|n;return t.slice(e,e+r)}}export function addInPlace(e,t){t.push(e)}export function addRangeInPlace(e,t){const r=getEnumerator(e);try{for(;r["System.Collections.IEnumerator.MoveNext"]();)addInPlace(r["System.Collections.Generic.IEnumerator`1.get_Current"](),t)}finally{disposeSafe(r)}}export function insertRangeInPlace(e,t,r){let n,o=e;const l=getEnumerator(t);try{for(;l["System.Collections.IEnumerator.MoveNext"]();){const e=l["System.Collections.Generic.IEnumerator`1.get_Current"]();n=0|o,r.splice(n,0,e),o=o+1|0}}finally{disposeSafe(l)}}export function removeInPlace(e,t,r){const n=0|indexOf(t,e,void 0,void 0,r);return n>-1&&(t.splice(n,1),!0)}export function removeAllInPlace(e,t){const r=n=>{const o=0|t.findIndex(e);return o>-1?(t.splice(o,1),r(n)+1|0):0|n};return 0|r(0)}export function partition(e,t,r){const n=0|t.length,o=Helpers_allocateArrayFromCons(r,n),l=Helpers_allocateArrayFromCons(r,n);let i=0,u=0;for(let r=0;r<=n-1;r++)e(t[r])?(o[i]=t[r],i=i+1|0):(l[u]=t[r],u=u+1|0);return[truncate(i,o),truncate(u,l)]}export function find(e,t){const r=t.find(e);return null==r?indexNotFound():value_2(r)}export function tryFind(e,t){return t.find(e)}export function findIndex(e,t){const r=0|t.findIndex(e);return r>-1?0|r:(indexNotFound(),-1)}export function tryFindIndex(e,t){const r=0|t.findIndex(e);return r>-1?r:void 0}export function pick(e,t){return(r=>{e:for(;;){const n=r;if(n>=t.length)return indexNotFound();{const o=e(t[n]);if(null!=o)return value_2(o);r=n+1;continue e}}})(0)}export function tryPick(e,t){return(r=>{e:for(;;){const n=r;if(n>=t.length)return;{const o=e(t[n]);if(null==o){r=n+1;continue e}return o}}})(0)}export function findBack(e,t){return(r=>{for(;;){const n=r;if(n<0)return indexNotFound();if(e(t[n]))return t[n];r=n-1}})(t.length-1)}export function tryFindBack(e,t){return(r=>{for(;;){const n=r;if(n<0)return;if(e(t[n]))return some(t[n]);r=n-1}})(t.length-1)}export function findLastIndex(e,t){return 0|(r=>{for(;;){const n=r;if(n<0)return-1;if(e(t[n]))return 0|n;r=n-1}})(t.length-1)}export function findIndexBack(e,t){return 0|(r=>{for(;;){const n=r;if(n<0)return indexNotFound(),-1;if(e(t[n]))return 0|n;r=n-1}})(t.length-1)}export function tryFindIndexBack(e,t){return(r=>{for(;;){const n=r;if(n<0)return;if(e(t[n]))return n;r=n-1}})(t.length-1)}export function choose(e,t,r){const n=[];for(let r=0;r<=t.length-1;r++){const o=e(t[r]);if(null!=o){const e=value_2(o);n.push(e)}}return equals_1(r,defaultOf())?n:map((e=>e),n,r)}export function foldIndexed(e,t,r){return r.reduce(((t,r,n)=>e(n,t,r)),t)}export function fold(e,t,r){return r.reduce(e,t)}export function iterate(e,t){for(let r=0;r<=t.length-1;r++)e(t[r])}export function iterateIndexed(e,t){for(let r=0;r<=t.length-1;r++)e(r,t[r])}export function iterate2(e,t,r){t.length!==r.length&&differentLengths();for(let n=0;n<=t.length-1;n++)e(t[n],r[n])}export function iterateIndexed2(e,t,r){t.length!==r.length&&differentLengths();for(let n=0;n<=t.length-1;n++)e(n,t[n],r[n])}export function isEmpty(e){return 0===e.length}export function forAll(e,t){return t.every(e)}export function permute(e,t){const r=0|t.length,n=t.slice(),o=new Array(r);if(iterateIndexed(((t,l)=>{const i=0|e(t);if(i<0||i>=r)throw new Error("Not a valid permutation");n[i]=l,o[i]=1}),t),!o.every((e=>1===e)))throw new Error("Not a valid permutation");return n}export function setSlice(e,t,r,n){const o=0|defaultArg(t,0),l=0|defaultArg(r,-1),i=(l>=0?l:e.length-1)-o|0;for(let t=0;t<=i;t++)e[t+o]=n[t]}export function sortInPlaceBy(e,t,r){t.sort(((t,n)=>r.Compare(e(t),e(n))))}export function sortInPlace(e,t){e.sort(((e,r)=>t.Compare(e,r)))}export function sort(e,t){const r=e.slice();return r.sort(((e,r)=>t.Compare(e,r))),r}export function sortBy(e,t,r){const n=t.slice();return n.sort(((t,n)=>r.Compare(e(t),e(n)))),n}export function sortDescending(e,t){const r=e.slice();return r.sort(((e,r)=>-1*t.Compare(e,r))),r}export function sortByDescending(e,t,r){const n=t.slice();return n.sort(((t,n)=>-1*r.Compare(e(t),e(n)))),n}export function sortWith(e,t){const r=e,n=t.slice();return n.sort(r),n}export function allPairs(e,t){const r=0|e.length,n=0|t.length,o=new Array(r*n);for(let r=0;r<=e.length-1;r++)for(let l=0;l<=t.length-1;l++)o[r*n+l]=[e[r],t[l]];return o}export function unfold(e,t){const r=[];return(t=>{for(;;){const n=e(t);if(null==n)break;{const e=n[0],o=n[1];r.push(e),t=o}}})(t),r}export function unzip(e){const t=0|e.length,r=new Array(t),n=new Array(t);return iterateIndexed(((e,t)=>{r[e]=t[0],n[e]=t[1]}),e),[r,n]}export function unzip3(e){const t=0|e.length,r=new Array(t),n=new Array(t),o=new Array(t);return iterateIndexed(((e,t)=>{r[e]=t[0],n[e]=t[1],o[e]=t[2]}),e),[r,n,o]}export function zip(e,t){e.length!==t.length&&differentLengths();const r=new Array(e.length);for(let n=0;n<=e.length-1;n++)r[n]=[e[n],t[n]];return r}export function zip3(e,t,r){e.length===t.length&&t.length===r.length||differentLengths();const n=new Array(e.length);for(let o=0;o<=e.length-1;o++)n[o]=[e[o],t[o],r[o]];return n}export function chunkBySize(e,t){if(e<1)throw new Error("The input must be positive.\\nParameter name: size");if(0===t.length)return[[]];{const r=[];for(let n=0;n<=~~Math.ceil(t.length/e)-1;n++){let o;const l=n*e|0;o=t.slice(l,l+e),r.push(o)}return r}}export function splitAt(e,t){let r;if(e<0||e>t.length)throw new Error(SR_indexOutOfBounds+"\\nParameter name: index");return[(r=0,t.slice(0,0+e)),t.slice(e)]}export function compareWith(e,t,r){if(null==t)return null==r?0:-1;if(null==r)return 1;{const n=0|t.length,o=0|r.length,l=0|(n<o?n:o);let i=0,u=0;for(;0===u&&i<l;)u=0|e(t[i],r[i]),i=i+1|0;return 0!==u?0|u:n>o?1:n<o?-1:0}}export function compareTo(e,t,r){if(null==t)return null==r?0:-1;if(null==r)return 1;{const n=0|t.length,o=0|r.length;if(n>o)return 1;if(n<o)return-1;{let o=0,l=0;for(;0===l&&o<n;)l=0|e(t[o],r[o]),o=o+1|0;return 0|l}}}export function equalsWith(e,t,r){if(null==t)return null==r;if(null==r)return!1;{let n=0,o=!0;const l=0|t.length,i=0|r.length;if(l>i)return!1;if(l<i)return!1;for(;n<l&&o;)o=e(t[n],r[n]),n=n+1|0;return o}}export function exactlyOne(e){if(1===e.length)return e[0];throw 0===e.length?new Error("The input sequence was empty\\nParameter name: array"):new Error("Input array too long\\nParameter name: array")}export function tryExactlyOne(e){return 1===e.length?some(e[0]):void 0}export function head(e){if(0===e.length)throw new Error("The input array was empty\\nParameter name: array");return e[0]}export function tryHead(e){return 0===e.length?void 0:some(e[0])}export function tail(e){if(0===e.length)throw new Error("Not enough elements\\nParameter name: array");return e.slice(1)}export function item(e,t){return t[e]}export function tryItem(e,t){return e<0||e>=t.length?void 0:some(t[e])}export function foldBackIndexed(e,t,r){return t.reduceRight(((t,r,n)=>e(n,r,t)),r)}export function foldBack(e,t,r){return t.reduceRight(((t,r)=>e(r,t)),r)}export function foldIndexed2(e,t,r,n){let o=t;if(r.length!==n.length)throw new Error("Arrays have different lengths");for(let t=0;t<=r.length-1;t++)o=e(t,o,r[t],n[t]);return o}export function fold2(e,t,r,n){return foldIndexed2(((t,r,n,o)=>e(r,n,o)),t,r,n)}export function foldBackIndexed2(e,t,r,n){let o=n;t.length!==r.length&&differentLengths();const l=0|t.length;for(let n=1;n<=l;n++)o=e(n-1,t[l-n],r[l-n],o);return o}export function foldBack2(e,t,r,n){return foldBackIndexed2(((t,r,n,o)=>e(r,n,o)),t,r,n)}export function reduce(e,t){if(0===t.length)throw new Error("The input array was empty");const r=e;return t.reduce(r)}export function reduceBack(e,t){if(0===t.length)throw new Error("The input array was empty");const r=e;return t.reduceRight(r)}export function forAll2(e,t,r){return fold2(((t,r,n)=>t&&e(r,n)),!0,t,r)}export function existsOffset(e,t,r){for(;;){const n=e,o=t,l=r;if(l===o.length)return!1;if(n(o[l]))return!0;e=n,t=o,r=l+1}}export function exists(e,t){return existsOffset(e,t,0)}export function existsOffset2(e,t,r,n){for(;;){const o=e,l=t,i=r,u=n;if(u===l.length)return!1;if(o(l[u],i[u]))return!0;e=o,t=l,r=i,n=u+1}}export function exists2(e,t,r){return t.length!==r.length&&differentLengths(),existsOffset2(e,t,r,0)}export function sum(e,t){let r=t.GetZero();for(let n=0;n<=e.length-1;n++)r=t.Add(r,e[n]);return r}export function sumBy(e,t,r){let n=r.GetZero();for(let o=0;o<=t.length-1;o++)n=r.Add(n,e(t[o]));return n}export function maxBy(e,t,r){return reduce(((t,n)=>r.Compare(e(n),e(t))>0?n:t),t)}export function max(e,t){return reduce(((e,r)=>t.Compare(r,e)>0?r:e),e)}export function minBy(e,t,r){return reduce(((t,n)=>r.Compare(e(n),e(t))>0?t:n),t)}export function min(e,t){return reduce(((e,r)=>t.Compare(r,e)>0?e:r),e)}export function average(e,t){if(0===e.length)throw new Error("The input array was empty\\nParameter name: array");let r=t.GetZero();for(let n=0;n<=e.length-1;n++)r=t.Add(r,e[n]);return t.DivideByInt(r,e.length)}export function averageBy(e,t,r){if(0===t.length)throw new Error("The input array was empty\\nParameter name: array");let n=r.GetZero();for(let o=0;o<=t.length-1;o++)n=r.Add(n,e(t[o]));return r.DivideByInt(n,t.length)}export function windowed(e,t){if(e<=0)throw new Error("windowSize must be positive");let r;const n=0|max_1(comparePrimitives,0,t.length-e+1);r=new Array(n);for(let n=e;n<=t.length;n++)r[n-e]=t.slice(n-e,n-1+1);return r}export function splitInto(e,t){if(e<1)throw new Error("The input must be positive.\\nParameter name: chunks");if(0===t.length)return[[]];{const r=[],n=0|min_1(comparePrimitives,e,t.length),o=0|~~(t.length/n),l=t.length%n|0;for(let e=0;e<=n-1;e++){const n=0|(e<l?o+1:o);let i;const u=e*o+min_1(comparePrimitives,l,e)|0;i=t.slice(u,u+n),r.push(i)}return r}}export function transpose(e,t){const r=Array.isArray(e)?e:Array.from(e),n=0|r.length;if(0===n)return new Array(0);{const e=0|r[0].length;forAll((t=>t.length===e),r)||differentLengths();const o=new Array(e);for(let l=0;l<=e-1;l++){o[l]=Helpers_allocateArrayFromCons(t,n);for(let e=0;e<=n-1;e++)o[l][e]=r[e][l]}return o}}export function insertAt(e,t,r,n){const o=0|r.length;if(e<0||e>o)throw new Error(SR_indexOutOfBounds+"\\nParameter name: index");const l=Helpers_allocateArrayFromCons(n,o+1);for(let t=0;t<=e-1;t++)l[t]=r[t];l[e]=t;for(let t=e;t<=o-1;t++)l[t+1]=r[t];return l}export function insertManyAt(e,t,r,n){const o=0|r.length;if(e<0||e>o)throw new Error(SR_indexOutOfBounds+"\\nParameter name: index");const l=Array.from(t),i=0|l.length,u=Helpers_allocateArrayFromCons(n,o+i);for(let t=0;t<=e-1;t++)u[t]=r[t];for(let t=0;t<=i-1;t++)u[e+t]=l[t];for(let t=e;t<=o-1;t++)u[t+i]=r[t];return u}export function removeAt(e,t){if(e<0||e>=t.length)throw new Error(SR_indexOutOfBounds+"\\nParameter name: index");let r=-1;return filter((t=>(r=r+1|0,r!==e)),t)}export function removeManyAt(e,t,r){let n=-1,o=-1;const l=filter((r=>(n=n+1|0,n===e?(o=0,!1):!(n>e&&(n<e+t||(o=1,0))))),r),i=0|(0===o&&n+1===e+t?1:o);if(i<1)throw new Error(SR_indexOutOfBounds+"\\nParameter name: "+(i<0?"index":"count"));return l}export function updateAt(e,t,r,n){const o=0|r.length;if(e<0||e>=o)throw new Error(SR_indexOutOfBounds+"\\nParameter name: index");const l=Helpers_allocateArrayFromCons(n,o);for(let n=0;n<=o-1;n++)l[n]=n===e?t:r[n];return l}