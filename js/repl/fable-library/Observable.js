import{Choice_tryValueIfChoice1Of2,Choice_tryValueIfChoice2Of2}from"./Choice.js";import{value}from"./Option.js";export class Observer{constructor(e,r,t){this.OnNext=e,this.OnError=r||(e=>{}),this.OnCompleted=t||(()=>{})}}class Observable{constructor(e){this.Subscribe=e}}export function protect(e,r,t){try{return r(e())}catch(e){t(e)}}export function add(e,r){r.Subscribe(new Observer(e))}export function choose(e,r){return new Observable((t=>r.Subscribe(new Observer((r=>protect((()=>e(r)),(e=>{null!=e&&t.OnNext(value(e))}),t.OnError)),t.OnError,t.OnCompleted))))}export function filter(e,r){return choose((r=>e(r)?r:null),r)}export function map(e,r){return new Observable((t=>r.Subscribe(new Observer((r=>{protect((()=>e(r)),t.OnNext,t.OnError)}),t.OnError,t.OnCompleted))))}export function merge(e,r){return new Observable((t=>{let n=!1,o=!1,s=!1;const c=e.Subscribe(new Observer((e=>{n||t.OnNext(e)}),(e=>{n||(n=!0,t.OnError(e))}),(()=>{n||(o=!0,s&&(n=!0,t.OnCompleted()))}))),i=r.Subscribe(new Observer((e=>{n||t.OnNext(e)}),(e=>{n||(n=!0,t.OnError(e))}),(()=>{n||(s=!0,o&&(n=!0,t.OnCompleted()))})));return{Dispose(){c.Dispose(),i.Dispose()}}}))}export function pairwise(e){return new Observable((r=>{let t;return e.Subscribe(new Observer((e=>{null!=t&&r.OnNext([t,e]),t=e}),r.OnError,r.OnCompleted))}))}export function partition(e,r){return[filter(e,r),filter((r=>!e(r)),r)]}export function scan(e,r,t){return new Observable((n=>t.Subscribe(new Observer((t=>{protect((()=>e(r,t)),(e=>{r=e,n.OnNext(e)}),n.OnError)}),n.OnError,n.OnCompleted))))}export function split(e,r){return[choose((r=>Choice_tryValueIfChoice1Of2(e(r))),r),choose((r=>Choice_tryValueIfChoice2Of2(e(r))),r)]}export function subscribe(e,r){return r.Subscribe(new Observer(e))}