module Тур.Функції

// Із https://docs.microsoft.com/en-us/dotnet/fsharp/tour
// Щоб дізнатися більше про кожну тему, перейдіть за посиланням вище
// Ви також можете знайти більше навчальних ресурсів за адресою https://fsharp.org/
// (лише англійською)

module ПростіФункції =

    /// Ви використовуєте 'нехай' для визначення функції. Ця приймає цілочисельний аргумент і повертає ціле число.
    /// Дужки необов’язкові для аргументів функції, за винятком випадків, коли ви явно анотуєте тип.
    let прикладФункії1 x = x*x + 3

    /// Застосуйте функцію, назвавши результат, який повертає функція, за допомогою 'нехай'.
    /// Тип змінної виводиться з типу результату функції.
    let результат1 = прикладФункії1 4573

    // Цей рядок використовує '%d' для друку результату як цілого числа. Це типо-безпечно.
    // Якщо 'результат1' буде не типу 'int', тоді цей рядок не зможе скомпілюватися.
    printfn "Результат зведення цілого числа 4573 у квадрат і додавання 3 дорівнює %d" результат1

    /// За потреби позначте тип назви параметра за допомогою '(аргумент:тип)'.  Дужки обов’язкові.
    let прикладФункії2 (x:int) = 2*x*x - x/5 + 3

    let результат2 = прикладФункії2 (7 + 4)
    printfn "Результатом застосування 2ї функції приклада до (7 + 4) є %d" результат2

    /// Умовне вживання якщо/тоді/інякщо/інакше.
    ///
    /// Зауважте, що у F# використовується синтаксис з урахуванням відступів пробілів, подібний до таких мов, як Python.
    let прикладФункії3 x =
        if x < 100.0 then
            2.0*x*x - x/5.0 + 3.0
        else
            2.0*x*x + x/5.0 - 37.0

    let результат3 = прикладФункії3 (6.5 + 4.5)

    // Цей рядок використовує '%f' для друку результату як числа з плаваючою точкою.  Як і у випадку із '%d' вище, це типо-безпечно.
    printfn "Результатом застосування 3ї функції приклада до (6.5 + 4.5) є %f" результат3


module Незмінність =

    /// Прив’язка значення до імені за допомогою 'нехай' робить значення незмінним.
    ///
    /// Другий рядок коду не компілюється, оскільки 'число' є незмінним і прив'язано.
    /// Повторне визначення 'число' щоб воно мало інше значення заборонено у Ф#.
    let число = 2
    // let число = 3

    /// Змінна прив'язка.  Це потрібно, щоб мати можливість змінювати значення 'іншеЧисло'.
    let mutable іншеЧисло = 2

    printfn "'іншеЧисло' дорівнює %d" іншеЧисло

    // Змінюючи значення, використовуйте '<-' щоб призначити нове значення.
    //
    // Зауважте, що '=' це не той саме що '<-'.  '=' використовується для перевірки рівності.
    іншеЧисло <- іншеЧисло + 1

    printfn "'іншеЧисло' змінено на %d" іншеЧисло


module КонвейерТаКомпозиція =

    /// Зводить значення в квадрат.
    let квадрат x = x * x

    /// Додає 1 до значення.
    let додатиОдин x = x + 1

    /// Перевіряє, чи є ціле значення непарним за модулем.
    let єНепарним x = x % 2 <> 0

    /// Список із 5 номерів.  Детальніше про списки пізніше.
    let числа = [ 1; 2; 3; 4; 5 ]

    /// Маючи список цілих чисел, він відфільтровує парні числа,
    /// зводить отримані непарні в квадра, та додає 1 до 
    /// зведених у квадрат непарних.
    let квадратНепарнихЗначеньТаДодатиОдин значення =
        let непарні = List.filter єНепарним значення
        let квадрати = List.map квадрат непарні
        let результат = List.map додатиОдин квадрати
        результат

    printfn "обробка %A через 'квадратНепарнихЗначеньТаДодатиОдин' дає: %A" числа (квадратНепарнихЗначеньТаДодатиОдин числа)

    /// Коротший спосіб написати 'квадратНепарнихЗначеньТаДодатиОдин' — це вкладати кожен
    /// підрезультат у виклики функіцй.
    ///
    /// Це робить функцію набагато коротшою, але важко побачити порядок у якому дані 
    /// обробляюься.
    let квадратНепарнихЗначеньТаДодатиОдинВкладена значення =
        List.map додатиОдин (List.map квадрат (List.filter єНепарним значення))

    printfn "обробка %A через 'квадратНепарнихЗначеньТаДодатиОдинВкладена' дає: %A" числа (квадратНепарнихЗначеньТаДодатиОдинВкладена числа)

    /// Бажаний спосіб написання 'квадратНепарнихЗначеньТаДодатиОдин' — використовувати конвеєрні оператори Ф#.
    /// Це дозволяє уникнути створення проміжних результатів, але набагато легше читається, ніж
    /// вкладені визови функцій як 'квадратНепарнихЗначеньТаДодатиОдинВкладена'
    let квадратНепарнихЗначеньТаДодатиОдинКонвейер значення =
        значення
        |> List.filter єНепарним
        |> List.map квадрат
        |> List.map додатиОдин

    printfn "обробка %A через 'квадратНепарнихЗначеньТаДодатиОдинКонвейер' дає: %A" числа (квадратНепарнихЗначеньТаДодатиОдинКонвейер числа)

    /// Ви можете скоротити 'квадратНепарнихЗначеньТаДодатиОдинКонвейер' перемістивши другий виклик `List.map`
    /// до першого за допомогою лямбда-функції.
    ///
    /// Зверніть увагу, що конвеєри також використовуються всередині лямбда-функції.  Конвеєрні оператори F# також можна 
    /// використовувати для окремих значень.  Це робить їх дуже потужними для обробки даних.
    let квадратНепарнихЗначеньТаДодатиОдинКоротшийКонвейер значення =
        значення
        |> List.filter єНепарним
        |> List.map(fun x -> x |> квадрат |> додатиОдин)

    printfn "обробка %A через 'квадратНепарнихЗначеньТаДодатиОдинКоротшийКонвейер' дає: %A" числа (квадратНепарнихЗначеньТаДодатиОдинКоротшийКонвейер числа)


module РекурсивніФункції =

    /// У цьому прикладі показано рекурсивну функцію, яка обчислює факториал цілого 
    /// числа. Він використовує 'нехай рек' для визначення рекурсивної функції.
    let rec факторіал n =
        if n = 0 then 1 else n * факторіал (n-1)

    printfn "Факторіал 6 дорівнює: %d" (факторіал 6)

    /// Обчислює найбільший спільний дільник двох цілих чисел.
    ///
    /// Оскільки всі рекурсивні виклики є кінцевими викликами,
    /// компілятор перетворить функцію на цикл,
    /// що покращує продуктивність і зменшує споживання пам'яті.
    let rec найбільшийСпільнийДільник a b =
        if a = 0 then b
        elif a < b then найбільшийСпільнийДільник a (b - a)
        else найбільшийСпільнийДільник (a - b) b

    printfn "найбільший спільний дільник 300 та 620 дорівнює %d" (найбільшийСпільнийДільник 300 620)

    /// Цей приклад обчислює суму списку цілих чисел за допомогою рекурсії.
    let rec сумСписка xs =
        match xs with
        | []    -> 0
        | y::ys -> y + сумСписка ys

    /// Це робить 'сумСписка' хвостово-рекурсивною, використовуючи допоміжну функцію з накопичувачем результату.
    let rec private сумСпискаХвостРекПомічник накопичувач xs =
        match xs with
        | []    -> накопичувач
        | y::ys -> сумСпискаХвостРекПомічник (накопичувач+y) ys

    /// Це викликає хвостову рекурсивну допоміжну функцію, надаючи '0' як початковий накопичувач.
    /// Подібний підхід поширений у Ф#.
    let сумСпискаХвостовоРекурсивна xs = сумСпискаХвостРекПомічник 0 xs

    let відОдногоДоДесяти = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

    printfn "Сума 1-10 дорівнює %d" (сумСпискаХвостовоРекурсивна відОдногоДоДесяти)


