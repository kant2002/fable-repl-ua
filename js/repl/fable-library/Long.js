import{isValid}from"./Int32.js";import*as LongLib from"./lib/long.js";export default LongLib.Long;export const get_Zero=LongLib.ZERO;export const get_One=LongLib.ONE;export const op_Addition=LongLib.add;export const op_Subtraction=LongLib.subtract;export const op_Multiply=LongLib.multiply;export const op_Division=LongLib.divide;export const op_Modulus=LongLib.modulo;export const op_UnaryNegation=LongLib.negate;export function op_UnaryPlus(o){return o}export const op_LeftShift=LongLib.shiftLeft;export const op_RightShift=LongLib.shiftRight;export const op_RightShiftUnsigned=LongLib.shiftRightUnsigned;export const op_BitwiseAnd=LongLib.and;export const op_BitwiseOr=LongLib.or;export const op_ExclusiveOr=LongLib.xor;export const op_LogicalNot=LongLib.not;export const op_LessThan=LongLib.lessThan;export const op_LessThanOrEqual=LongLib.lessThanOrEqual;export const op_GreaterThan=LongLib.greaterThan;export const op_GreaterThanOrEqual=LongLib.greaterThanOrEqual;export const op_Equality=LongLib.equals;export const op_Inequality=LongLib.notEquals;export const equals=LongLib.equals;export const compare=LongLib.compare;export const fromInt=LongLib.fromInt;export const fromBits=LongLib.fromBits;export const fromBytes=LongLib.fromBytes;export const fromNumber=LongLib.fromNumber;export const fromString=LongLib.fromString;export const fromValue=LongLib.fromValue;export const toInt=LongLib.toInt;export const toBytes=LongLib.toBytes;export const toNumber=LongLib.toNumber;export const toString=LongLib.toString;export const getLowBits=LongLib.getLowBits;export const getHighBits=LongLib.getHighBits;export const getLowBitsUnsigned=LongLib.getLowBitsUnsigned;export const getHighBitsUnsigned=LongLib.getHighBitsUnsigned;function getMaxValue(o,t,n){switch(t){case 2:return o?"1111111111111111111111111111111111111111111111111111111111111111":n?"1000000000000000000000000000000000000000000000000000000000000000":"111111111111111111111111111111111111111111111111111111111111111";case 8:return o?"1777777777777777777777":n?"1000000000000000000000":"777777777777777777777";case 10:return o?"18446744073709551615":n?"9223372036854775808":"9223372036854775807";case 16:return o?"FFFFFFFFFFFFFFFF":n?"8000000000000000":"7FFFFFFFFFFFFFFF";default:throw new Error("Invalid radix.")}}export function abs(o){return!o.unsigned&&LongLib.isNegative(o)?op_UnaryNegation(o):o}export function fromInteger(o,t,n){let e=o,i=0;switch(n){case 0:e=o<<24>>24,i=e;break;case 4:e=o<<24>>>24;break;case 1:e=o<<16>>16,i=e;break;case 5:e=o<<16>>>16;break;case 2:e=o>>0,i=e;break;case 6:e=o>>>0}return LongLib.fromBits(e,i>>31,t)}export function parse(o,t,n,e,i){const r=isValid(o,t,i);if(null!=r){const t=(o,t)=>{const n=Math.max(o.length,t.length);return o.padStart(n,"0")<=t.padStart(n,"0")},e="-"===r.sign,i=getMaxValue(n||10!==r.radix,r.radix,e);if(t(r.digits.toUpperCase(),i))return o=e?r.sign+r.digits:r.digits,LongLib.fromString(o,n,r.radix)}throw new Error("Input string was not in a correct format.")}export function tryParse(o,t,n,e,i){try{return i.contents=parse(o,t,n,e),!0}catch(o){return!1}}export function unixEpochMillisecondsToTicks(o,t){return op_Multiply(op_Addition(op_Addition(LongLib.fromNumber(o),621355968e5),t),1e4)}export function ticksToUnixEpochMilliseconds(o){return LongLib.toNumber(op_Subtraction(op_Division(o,1e4),621355968e5))}export function divRem(o,t,n){const e=op_Division(o,t),i=op_Modulus(o,t);return void 0===n?[e,i]:(n.contents=i,e)}