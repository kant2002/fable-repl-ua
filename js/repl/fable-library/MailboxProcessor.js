import{defaultCancellationToken}from"./Async.js";import{fromContinuations}from"./Async.js";import{startImmediate}from"./Async.js";class QueueCell{constructor(t){this.value=t}}class MailboxQueue{add(t){const s=new QueueCell(t);this.firstAndLast?(this.firstAndLast[1].next=s,this.firstAndLast=[this.firstAndLast[0],s]):this.firstAndLast=[s,s]}tryGet(){if(this.firstAndLast){const t=this.firstAndLast[0].value;return this.firstAndLast[0].next?this.firstAndLast=[this.firstAndLast[0].next,this.firstAndLast[1]]:delete this.firstAndLast,t}}}export class MailboxProcessor{constructor(t,s){this.body=t,this.cancellationToken=s||defaultCancellationToken,this.messages=new MailboxQueue}}function __processEvents(t){if(t.continuation){const s=t.messages.tryGet();if(s){const n=t.continuation;delete t.continuation,n(s)}}}export function startInstance(t){startImmediate(t.body(t),t.cancellationToken)}export function receive(t){return fromContinuations((s=>{if(t.continuation)throw new Error("Receive can only be called once!");t.continuation=s[0],__processEvents(t)}))}export function post(t,s){t.messages.add(s),__processEvents(t)}export function postAndAsyncReply(t,s){let n,e;function o(){void 0!==n&&void 0!==e&&e(n)}const i={reply:t=>{n=t,o()}};return t.messages.add(s(i)),__processEvents(t),fromContinuations((t=>{e=t[0],o()}))}export function start(t,s){const n=new MailboxProcessor(t,s);return startInstance(n),n}export default MailboxProcessor;