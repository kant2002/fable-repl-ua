module Тур.Об'еднання

// Із https://docs.microsoft.com/en-us/dotnet/fsharp/tour
// Щоб дізнатися більше про кожну тему, перейдіть за посиланням вище
// Ви також можете знайти більше навчальних ресурсів за адресою https://fsharp.org/
// (лише англійською)

module РозділяючіОб'еднання =

    /// Тип нижче представляє масть гральної карти.
    type Масть =
        | Чирва
        | Піка
        | Бубна
        | Трефа

    /// Розділяючі Об'еднання може бути використовано для ранга карти A Discriminated Union can also be used to represent the rank of a playing card.
    type Ранг =
        /// Представляє усі ранги карт від 2 до 10
        | Значення of int
        | Туз
        | Король
        | Дама
        | Валет

        /// Розділяючі Об'еднання також можуть реалізовувати об'єктно орієнтовні члени.
        static member ВзятиУсіРанги() =
            [ yield Туз
              for i in 2 .. 10 do yield Значення i
              yield Валет
              yield Дама
              yield Король ]

    /// Це тип запису який комбінує Масть і Ранг.
    /// Це дуже типово використовувати як Записи так і Розділяючиоб'еднання коли моделюєш дані.
    type Карта = { Масть: Масть; Ранг: Ранг }

    /// Ця декларація обчислить список представляючий усі карти у колоді.
    let повнаКолода =
        [ for масть in [ Чирва; Бубна; Піка; Трефа] do
              for ранг in Ранг.ВзятиУсіРанги() do
                  yield { Масть=масть; Ранг=ранг } ]

    /// Цей приклад конвертує об'єкт 'Карта' до рядка.
    let показатиГральнуКарту (к: Карта) =
        let рядокРанга =
            match к.Ранг with
            | Туз -> "Туз"
            | Король -> "Король"
            | Дама -> "Дама"
            | Валет -> "Валет"
            | Значення ч -> string ч
        let рядокМасті =
            match к.Масть with
            | Піка -> "пік"
            | Бубна -> "бубен"
            | Трефа -> "треф"
            | Чирва -> "чирвей"
        рядокРанга  + " " + рядокМасті

    /// Цей приклад надрукує усі карти у гральній колоді.
    let надрукуватиУсіКарти() =
        for карта in повнаКолода do
            printfn "%s" (показатиГральнуКарту карта)


    // РО із одиничним варіантом часто використовуюється для моделювання зон контролю(domain modelling). Це може дати вам додаткову This can buy you extra type safety
    // безпеку типів над примітивними типами такими як рядки або цілі.
    //
    // РО із одиничним варіантом не можуть неявно конвертуватися у, або із типу який вони огортають.
    // Наприклад, фцнкція яка приймає Адреса не може прийняти рядок як вхідні дані,
    // або навпаки.
    type Адреса = Адреса of string
    type Ім'я = Ім'я of string
    type ІІН = ІІН of int

    // Ви можете легко створити екземпляр РО із одиничним варіантом наступним чином.
    let адреса = Адреса "111 Alf Way"
    let ім'я = Ім'я "Alf"
    let іін = ІІН 1234567890

    /// Коли вам потрібно значення, ви можете розгорнути значення що лежить у основі за допомогою простої функції.
    let розгорнутиАдресу (Адреса а) = а
    let розгорнутиІм'я (Ім'я і) = і
    let розгорнутиІІН (ІІН с) = с

    // Друкування РО із одиничним варіантом це просто із допомогою розгортаючих функцій.
    printfn "Адреса: %s, Ім'я: %s та ІІН: %d" (адреса |> розгорнутиАдресу) (ім'я |> розгорнутиІм'я) (іін |> розгорнутиІІН)


    /// Розділяючи Об'єднання також підтримують рекурсивні визначення.
    ///
    /// Цей тип представляє Бінарне Дерево Пошуку, із одним варіантом Пусте дерево,
    /// та іншим варіантом Вузел із значенням і двома піддеревами.
    type БДП<'Т> =
        | Пусте
        | Вузел of значення:'Т * лівий: БДП<'Т> * правий: БДП<'Т>

    /// Перевіряє чи існує елементі у бінарному дереві пошука.
    /// Шукає рекурсивно використовуючи Відповідність Шаблону.  Повертає істина якщо він існіє; інакше, лож.
    let rec існує елемент бпд =
        match бпд with
        | Пусте -> false
        | Вузел (з, ліве, праве) ->
            if елемент = з then true
            elif елемент < з then (існує елемент ліве) // Перевірити ліве піддерево.
            else (існує елемент праве) // Перевірити праве піддерево.

    /// Вставляє елемент у Бінарне Дерево Пошуку.
    /// Знаходить місце для вставки рекурсивно використовуючи Відповідність Шаблону, потім вставляє новий вузел.
    /// Якщо елемент вже існує, функція не вставляє нічого.
    let rec вставити елемент бдп =
        match бдп with
        | Пусте -> Вузел(елемент, Пусте, Пусте)
        | Вузел(з, ліве, праве) as вузел ->
            if елемент = з then вузел // Не треба вставляти, він вже існує; повернути вузел.
            elif елемент < з then Вузел(з, вставити елемент ліве, праве) // Викликати у ліве піддерево.
            else Вузел(з, ліве, вставити елемент праве) // Викликати у праве піддерево.


module ВідповідністьШаблону =
    open System

    /// Запис для ім'я так фамілії людини
    type Людина = {
        Ім'я : string
        Фамілія  : string
    }

    /// Розділяюче Об'єднання трьох різних видів співробітників
    type Співробітник =
        | Інжинер of інжинер: Людина
        | Керівник of керівник: Людина * підлеглі: List<Співробітник>
        | Виконавчий of виконавчий: Людина * підлеглі: List<Співробітник> * помічник: Співробітник

    /// Підраховує усіх під співробітником у ієрархії керування,
    /// включючи співробітника. Співставлення зв'язує імена із властивостями
    /// варіантів таким чином щоб ці імена можна було використовувати всередині гілок співставлення.
    /// Зауважте що імені використані при зв'язуванні не повинні бути тими самими іменами яка були
    /// дані у визначенні РО вищче.
    let rec підрахуватиПідлеглих(спів : Співробітник) =
        1 + match спів with
            | Інжинер(людина) ->
                0
            | Керівник(людина, підлеглі) ->
                підлеглі |> List.sumBy підрахуватиПідлеглих
            | Виконавчий(людина, підлеглі, помічник) ->
                (підлеглі |> List.sumBy підрахуватиПідлеглих) + підрахуватиПідлеглих помічник


    /// Знайти усіх менеджерів/виконавчих із ім'ям "Богдан" у яких немає ніяких підлеглих.
    /// Приклад використовує скорочення 'function' для лямбда виразу.
    let rec знайтиБогданаІзВідкритимиПозіціями(спів : List<Співробітник>) =
        спів
        |> List.filter(function
                       | Керівник({Ім'я = "Богдан"}, []) -> true // [] співставляє пустий список.
                       | Виконавчий({Ім'я = "Богдан"}, [], _) -> true
                       | _ -> false) // '_' це шаблон підстановки який співставляє будь-що.
                                     // Він обробляє випадок "інакше".


    /// You can also use the shorthand function construct for pattern matching,
    /// which is useful when you're writing functions which make use of Partial Application.
    let private помічникРозбору ф = ф >> function
        | (true, елемент) -> Some елемент
        | (false, _) -> None

    let розібратиДатуЧасСдвиг: string -> _ = помічникРозбору DateTimeOffset.TryParse

    let результат = розібратиДатуЧасСдвиг "1970-01-01"
    match результат with
    | Some опд -> printfn "Воно розібралося!"
    | None -> printfn "Воно не розібралося!"

    // Визначемо більше функції які розбирають за допомогою вспоміжної функції.
    let розібратиЦіл: string -> _  = помічникРозбору Int32.TryParse
    let розібратиДвойне: string -> _  = помічникРозбору Double.TryParse
    let розібратиВідрізокЧасу: string -> _  = помічникРозбору TimeSpan.TryParse


    // Активні Шаблони це інша потужна конструкія для використання із відповідністю шаблону.
    // Вони дозволяють вам розділяти вхідні дані на довільні форми, декомпозуючи їх у місці виклику відповідності шаблону.
    //
    // Щоб дізнатися більше, дивиться: https://docs.microsoft.com/dotnet/fsharp/language-reference/active-patterns
    // (лише англійською)
    let (|Ціл|_|) = розібратиЦіл
    let (|Двойне|_|) = розібратиДвойне
    let (|Дата|_|) = розібратиДатуЧасСдвиг
    let (|ВідрізокЧасу|_|) = розібратиВідрізокЧасу

    /// Відповідність Шаблону через ключове слово 'function' та Активні Шаблони зазвичай виглядає так.
    let надрукуватиРезультатРозбору = function
        | Ціл з -> printfn "%d" з
        | Двойне з -> printfn "%f" з
        | Дата д -> printfn "%s" (д.ToString())
        | ВідрізокЧасу ч -> printfn "%s" (ч.ToString())
        | _ -> printfn "Нічого що можна розібрати!"

    // Викликає друкувальника із деякими різними значеннями для розбору.
    надрукуватиРезультатРозбору "12"
    надрукуватиРезультатРозбору "12.045"
    надрукуватиРезультатРозбору "12/28/2016"
    надрукуватиРезультатРозбору "9:01PM"
    надрукуватиРезультатРозбору "banana!"


module ОпціональніЗначення =
    /// Опціональні значення це будь які значення помічені або 'Some' або 'None'.
    /// Вони широко використовуються у F# коді для того щоб представляти варіанти де багато інших мов би використовували
    /// посилання на нулл.
    ///
    /// Щоб дізнатися більше, дивиться: https://docs.microsoft.com/dotnet/fsharp/language-reference/options
    /// (лише англійською)

    /// Спочатку, визначемо індекс як Розподіляюче Об'єднання із Одним Варіантом.
    type Індекс = Індекс of string

    /// Далі, визначемо тип деІндекс є необов'язковим.
    type Клієнт = { Індекс: Індекс option }

    /// Далі, визначемо тип інтерфейсу який представляє об'єкт для обчислення зони доставки за індексом клієнта,
    /// маючи реалізаціі для абстрактних методів 'getState' та 'getShippingZone' abstract methods.
    type ІКалькуляторДоставки =
        abstract ВзятиОбласть : Індекс -> string option
        abstract ВзятиЗонуДоставки : string -> int

    /// Далі, розрахуємо зону доставки для клієнта використовуючи екземпляр калькулятора.
    /// Це приклад використовує комбінатори у модуля Option щоб забезпечити функціональний конвеєр для
    /// трансформації даних із Опціоналами.
    let ЗонаДоставкиКлієнта (калькулятор: ІКалькуляторДоставки, клієнт: Клієнт) =
        клієнт.Індекс
        |> Option.bind калькулятор.ВзятиОбласть
        |> Option.map калькулятор.ВзятиЗонуДоставки

